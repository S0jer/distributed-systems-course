# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `actions.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module actions
_M_actions = Ice.openModule('actions')
__name__ = 'actions'

_M_actions._t_Booster = IcePy.defineValue('::actions::Booster', Ice.Value, -1, (), False, True, None, ())

if 'BoosterPrx' not in _M_actions.__dict__:
    _M_actions.BoosterPrx = Ice.createTempClass()
    class BoosterPrx(Ice.ObjectPrx):

        def boostAndReturn(self, number, context=None):
            return _M_actions.Booster._op_boostAndReturn.invoke(self, ((number, ), context))

        def boostAndReturnAsync(self, number, context=None):
            return _M_actions.Booster._op_boostAndReturn.invokeAsync(self, ((number, ), context))

        def begin_boostAndReturn(self, number, _response=None, _ex=None, _sent=None, context=None):
            return _M_actions.Booster._op_boostAndReturn.begin(self, ((number, ), _response, _ex, _sent, context))

        def end_boostAndReturn(self, _r):
            return _M_actions.Booster._op_boostAndReturn.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_actions.BoosterPrx.ice_checkedCast(proxy, '::actions::Booster', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_actions.BoosterPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::actions::Booster'
    _M_actions._t_BoosterPrx = IcePy.defineProxy('::actions::Booster', BoosterPrx)

    _M_actions.BoosterPrx = BoosterPrx
    del BoosterPrx

    _M_actions.Booster = Ice.createTempClass()
    class Booster(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::actions::Booster')

        def ice_id(self, current=None):
            return '::actions::Booster'

        @staticmethod
        def ice_staticId():
            return '::actions::Booster'

        def boostAndReturn(self, number, current=None):
            raise NotImplementedError("servant method 'boostAndReturn' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_actions._t_BoosterDisp)

        __repr__ = __str__

    _M_actions._t_BoosterDisp = IcePy.defineClass('::actions::Booster', Booster, (), None, ())
    Booster._ice_type = _M_actions._t_BoosterDisp

    Booster._op_boostAndReturn = IcePy.Operation('boostAndReturn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), IcePy._t_int, False, 0), ())

    _M_actions.Booster = Booster
    del Booster

_M_actions._t_Database = IcePy.defineValue('::actions::Database', Ice.Value, -1, (), False, True, None, ())

if 'DatabasePrx' not in _M_actions.__dict__:
    _M_actions.DatabasePrx = Ice.createTempClass()
    class DatabasePrx(Ice.ObjectPrx):

        def toUpperCaseAndSave(self, info, context=None):
            return _M_actions.Database._op_toUpperCaseAndSave.invoke(self, ((info, ), context))

        def toUpperCaseAndSaveAsync(self, info, context=None):
            return _M_actions.Database._op_toUpperCaseAndSave.invokeAsync(self, ((info, ), context))

        def begin_toUpperCaseAndSave(self, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_actions.Database._op_toUpperCaseAndSave.begin(self, ((info, ), _response, _ex, _sent, context))

        def end_toUpperCaseAndSave(self, _r):
            return _M_actions.Database._op_toUpperCaseAndSave.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_actions.DatabasePrx.ice_checkedCast(proxy, '::actions::Database', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_actions.DatabasePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::actions::Database'
    _M_actions._t_DatabasePrx = IcePy.defineProxy('::actions::Database', DatabasePrx)

    _M_actions.DatabasePrx = DatabasePrx
    del DatabasePrx

    _M_actions.Database = Ice.createTempClass()
    class Database(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::actions::Database')

        def ice_id(self, current=None):
            return '::actions::Database'

        @staticmethod
        def ice_staticId():
            return '::actions::Database'

        def toUpperCaseAndSave(self, info, current=None):
            raise NotImplementedError("servant method 'toUpperCaseAndSave' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_actions._t_DatabaseDisp)

        __repr__ = __str__

    _M_actions._t_DatabaseDisp = IcePy.defineClass('::actions::Database', Database, (), None, ())
    Database._ice_type = _M_actions._t_DatabaseDisp

    Database._op_toUpperCaseAndSave = IcePy.Operation('toUpperCaseAndSave', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), None, ())

    _M_actions.Database = Database
    del Database

_M_actions._t_Subtractor = IcePy.defineValue('::actions::Subtractor', Ice.Value, -1, (), False, True, None, ())

if 'SubtractorPrx' not in _M_actions.__dict__:
    _M_actions.SubtractorPrx = Ice.createTempClass()
    class SubtractorPrx(Ice.ObjectPrx):

        def subtract(self, fundamental, retracent, context=None):
            return _M_actions.Subtractor._op_subtract.invoke(self, ((fundamental, retracent), context))

        def subtractAsync(self, fundamental, retracent, context=None):
            return _M_actions.Subtractor._op_subtract.invokeAsync(self, ((fundamental, retracent), context))

        def begin_subtract(self, fundamental, retracent, _response=None, _ex=None, _sent=None, context=None):
            return _M_actions.Subtractor._op_subtract.begin(self, ((fundamental, retracent), _response, _ex, _sent, context))

        def end_subtract(self, _r):
            return _M_actions.Subtractor._op_subtract.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_actions.SubtractorPrx.ice_checkedCast(proxy, '::actions::Subtractor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_actions.SubtractorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::actions::Subtractor'
    _M_actions._t_SubtractorPrx = IcePy.defineProxy('::actions::Subtractor', SubtractorPrx)

    _M_actions.SubtractorPrx = SubtractorPrx
    del SubtractorPrx

    _M_actions.Subtractor = Ice.createTempClass()
    class Subtractor(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::actions::Subtractor')

        def ice_id(self, current=None):
            return '::actions::Subtractor'

        @staticmethod
        def ice_staticId():
            return '::actions::Subtractor'

        def subtract(self, fundamental, retracent, current=None):
            raise NotImplementedError("servant method 'subtract' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_actions._t_SubtractorDisp)

        __repr__ = __str__

    _M_actions._t_SubtractorDisp = IcePy.defineClass('::actions::Subtractor', Subtractor, (), None, ())
    Subtractor._ice_type = _M_actions._t_SubtractorDisp

    Subtractor._op_subtract = IcePy.Operation('subtract', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), ())

    _M_actions.Subtractor = Subtractor
    del Subtractor

# End of module actions
